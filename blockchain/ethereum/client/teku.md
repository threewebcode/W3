# Teku Consensus Client

The build system has plugin mechanism. The configuration is responsible for setting items, their values and how to get them. The API has read and write interfaces for data request and post. The converter is needed to transform original data to expected format. 

The single channel or bidirectional channel could be created for files on the operating system. The file poll is to read and write file continuously. The key and oracle is constrained by interface definition. The oracle can be implemented by network data stream or local storage stream. 

How to create variables and use them is the key question in the programming. Build and deploy projects are two ordered processes. One target in make file is equal to one function in the bash script. The command line application is written to do something. The latest unsafe block is located in the execution engine side. 

The files and directories are ignored if git ignore file is specified. The same chain names have different networks. The configuration are different between different networks. The chain name is same as fork name. The chain is identified by chain id. The transaction metadata can be fetched from execution layer, however, the blob data must be retrieved from beacon client.

When you learn new programming language, you must know how to create command line application by this new language. The transaction is made of transaction frames. The golang bindings are generated from Solidity language codes. The code bindings are used to make call with smart contracts deployed on the layer one network. The data view should be provided by command line tools. 

The peer id is derived from private key. The bytes are converted to hex string value. When layer one block hash is known, the layer two block output can be queried again output oracle contract on the layer one network. Safe head and block hash are from layer one network. 

The best headers from layer one network can be subscribed for event processing. Safe head information are persisted into database storage. The P2P network protocol is implemented by P2PNode object and bound with primary node object. The peer is scored for performance and choice. 

The calldata can be extracted from transaction. Transaction logs are captured by contract events. The type is used to distinguish similar things. Different aspects of data are sourced and derived. The steps of derivation are pipelined. The contract address must be known before it is invoked. The data frame has clear and fixed data format. 

The genesis payload and state is checked at the first step. The block number, block hash, parent hash, sequence number, layer one origin and timestamps are the ingredients of layer two block. The parameters are always constant variables. The configuration is always dynamic variables. The state of layer one is traced to trigger layer two block derivation. 

The execution engine is managed by the controller. Three kinds of engine clients are supported. The math problem is how to find layer one's origin block when layer two's head is known. The solution is to check current layer one's origin block and find next one by adding block number if the current origin lags behind. This aspect is implemented by origin selector and its algorithm. The context, log and lock are basic elements of structure definition. 
